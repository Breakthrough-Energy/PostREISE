import pandas as pd
import matplotlib.pyplot as plt

from collections import OrderedDict
from postreise.plot.analyze_pg import AnalyzePG as apg
from powersimdata.scenario.scenario import Scenario

from postreise.plot.multi.constants import ZONES, SCENARIO_RESOURCE_TYPES

# Checks input validity for plotting code, fetches data if necessary
# param: interconnect: either 'Western' or 'Texas'
# param scenario_ids: optional list(string) of scenario ids
# param: custom_data: optional hand-generated data 
# returns: formatted graph data (scenario data and custom data combined into one dict) and list of all zones in interconnect
def handle_plot_inputs(interconnect, scenario_ids, custom_data):
    if interconnect in ZONES.keys():
        zone_list = ZONES[interconnect]
    else:
        raise ValueError('ERROR: zone must be one of Western or Texas')
    if scenario_ids == None and custom_data == None:
        raise ValueError("ERROR: must include scenario ids and/or custom data")
    if scenario_ids != None:
        scenario_data = _get_scenario_data(scenario_ids, zone_list)
    else: 
        scenario_data = {}   
    if custom_data == None:
        custom_data = {}

    graph_data = OrderedDict(scenario_data, **custom_data)
    return (zone_list, graph_data)

# Checks input validity for shortfall plotting code, fetches data if necessary
# param: interconnect: either 'Western' or 'Texas'
# param scenario_ids: optional list(string) of scenario ids
# param: custom_data: optional hand-generated data
# is_match_CA (optional): bool: calculate shortfall using special rules that apply when all zones match California goals
# has_collaborative_scenarios: list(string): list of scenario ids where all zones collaborate to meet goals. Affects results for interconnect
# baselines (optional): dict {zone: int generation in TWh} baseline renewables generation for each zone
# targets (optional): dict {zone: int generation in TWh} target renewables renewable generation for each zone
# demand (optional): dict {zone: int demand in TWh} total demand for each zone
# returns: formatted graph data (scenario data and custom data combined into one dict) and list of all zones in interconnect
def handle_shortfall_inputs(interconnect, scenario_ids, custom_data, is_match_CA, baselines, targets, demand):
    zone_list, graph_data = handle_plot_inputs(interconnect, scenario_ids, custom_data)

    baselines = _fetch_baselines() if baselines == None else baselines
    targets = _fetch_targets(is_match_CA) if targets == None else targets
    demand = _fetch_demand() if demand == None else demand

    return zone_list, graph_data, baselines, targets, demand

# Unit conversion: converts between metric units and rounds to two decimal places
# :param val: int: the value to change
# :param change: int: the distance between the starting unit and the desired unit.
# eg 2,500,000 MWh to TWh would be unit_conversion(2500000, 2), resulting in 2.50 TWh
def unit_conversion(val, change): return round(val/1000**change, 2)

# For each scenario, fetches data and then formats it so it's usable by our plotting code
# param scenario_ids: list(string) of scenario ids
# param zone_list: list(string) of zone names 
# returns: formatted scenario data
def _get_scenario_data(scenario_ids, zone_list):
    scenario_data = OrderedDict()
    for id in scenario_ids:
        data_chart, scenario_name = _get_data_chart_from_scenario(id, zone_list)
        scenario_data[id] = _format_scenario_data(data_chart, scenario_name)
    
    return scenario_data

# Uses apg to fetch and format data for a scenario
# param scenario_id: string: the id of the scenario to fetch
# param zone_list: list(string) of zone names 
# returns: scenario data chart generated by apg, scenario name
# TODO do this ourselves instead of using apg as a middle man
def _get_data_chart_from_scenario(scenario_id, zone_list):
    scenario = Scenario(scenario_id)
    scenario_name = scenario.info['name']
    data_chart = apg(scenario,
                ('2016-01-01-00', '2016-12-31-23', 'utc', 'H'),
                zone_list,
                SCENARIO_RESOURCE_TYPES,
                'chart', normalize=False).get_data()
    plt.close('all')
    return data_chart, scenario_name

# Takes a data chart from a scenario and transforms it into a format usable by our plotting code
# data_chart: zone -> gen/cap -> resource_type -> vals for each date
# formatted_data: gen/cap -> zone -> resource_type -> rolled up values
def _format_scenario_data(data_chart, scenario_name):
    formatted_data = {
        'label': scenario_name,
        'gen': {
            'label': 'Generation',
            'unit': 'TWh',
            'data': {}
        },
        'cap': {
            'label': 'Capacity',
            'unit': 'GW',
            'data': {}
        }
    }

    gen_data = {}  
    cap_data = {}
    for zone in data_chart.keys():
        gen_data[zone] = {}
        cap_data[zone] = {}

        for resource in data_chart[zone]['Generation'].keys():
            gen_data[zone][resource] = unit_conversion(sum(data_chart[zone]['Generation'][resource].values()), 2) #MWh to TWh
            cap_data[zone][resource] = unit_conversion(data_chart[zone]['Capacity'][resource], 1) #MW to GW

    formatted_data['gen']['data'] = gen_data
    formatted_data['cap']['data'] = cap_data

    return formatted_data

# Built for some custom CSVs given to me
# TODO: Maybe we should remove it?
def _get_data_chart_from_csv(file_loc_1, file_loc_2, region, index='(in MW)'):
    data = []
    for file_loc in [file_loc_1, file_loc_2]:
        df = pd.read_csv(file_loc, sep=',', thousands=',')
        df = df.replace('Totals by Gen Type', region)
        df = df.replace('Western Montana ', 'Western Montana')
        df = df.replace([' -   ', '-   '], 0)
        df = df.set_index(index)
        df = df.drop(['Storage', 'Totals by State', 'Totals by Zone', 'load', 'Unnamed: 11', 'Unnamed: 12', 'Unnamed: 13'], axis=1, errors='ignore')
        df.columns = ['coal', 'geothermal', 'hydro', 'ng', 'nuclear', 'solar', 'wind', 'other inc. biomass']
        df = df[['other inc. biomass', 'coal', 'geothermal', 'hydro', 'ng', 'nuclear', 'solar', 'wind']]
        
        df = df.T
        print(df, f'\n\n')
        data.append(df.to_dict())

    return data

# Imports baseline data from a locally stored csv
def _fetch_baselines():
    baselines = {} # TODO import from csv
    return baselines

# Imports target data from a locally stored csv
def _fetch_targets(is_match_CA):
    if is_match_CA:
        targets = {} # TODO import from csv
    else:
        targets = {} # TODO import from csv
    return targets

# Imports demand data from a locally stored csv
def _fetch_demand():
    demand = {} # TODO import from csv
    return demand

